#!/usr/bin/env python3

# Despoina Kotsidou       2475
# Anastasia Monastiridou  2488

import sys
file_to_compile = ' '

# ta // mi ksexasoume

#############################
#                           #
#       TOKEN TYPES         #
#                           #
#############################

PROGR       = 1
ENDPROG     = 2
DECLAR      = 3
FUNC        = 4
ENDFUNC     = 5
IN          = 6
INOUT       = 7
INANDOUT    = 8
IF          = 9
THEN        = 10
ENDIF       = 11
ELSE        = 12
WHILE       = 13
ENDWHILE    = 14
DO          = 15
LOOP        = 16
ENDLOOP     = 17
EXIT        = 18
FORCASE     = 19
WHEN        = 20
DEFAULT     = 21
ENDDEFAULT  = 22
ENDFORCASE  = 23
INCASE      = 24
ENDINCASE   = 25
RETURN      = 26
PRINT       = 27
INPUT       = 28
OR          = 29
AND         = 30
NOT         = 31

LEFTPARENTH = 32
RIGHTPARENTH= 33
LEFTBRACK   = 34
RIGHTBRACK  = 35
EQUALS      = 36
LESS        = 37
BIGGER      = 38
DIFF        = 39
LESSEQ      = 40
BIGEQ       = 41
PLUS        = 42
MINUS       = 43
TIMES       = 44
DIV         = 45
SEMICOL     = 46
COMMA		= 47

ID          = 48
NUMBER      = 49


token = ''

class Token:
	def __init__(self, mylist1, typ):
		self.mylist1 = mylist1
		self.typ = typ

def program():
	print()

def block():
	print()

def declaration():
	print()

def varlist():
	print()

def subprograms():
	print()

def subprogram():
	print()

def funcbody():
	print()

def formalpars():
	print()

def formalparlist():
	print()

def formalparitem():
	print()

def statements():
	print()

def statement():
	print()

def assignmentStat():
	print()

def ifStat():
	if token.typ == IF:
		lex()
		if token.typ == LEFTPARENTH:
			lex()
			condition()
			lex()
			if not(token.typ == RIGHTPARENTH):
				print('File: ', file_to_compile)
				print("ERROR: ' ) ' expected")
			lex()
			if token.typ == THEN:
				lex()
				statements()
				lex()
				elsepart()
				lex()
				if not(token.typ == ENDIF):
					print('File: ', file_to_compile )
					print("ERROR: ' endif ' expected")

			else:
				print('File: ', file_to_compile )
				print("ERROR: ' then ' expected")
		else:
			print('File: ', file_to_compile )
			print("ERROR: ' ( ' expected")

def elsepart():
	if token.typ == ELSE:
		lex()
		statements()

def whileStat():
	if token.typ == WHILE:
		lex()
		if token.typ == LEFTPARENTH:
			lex()
			condition()
			lex()
			if not(token.typ == RIGHTPARENTH):
				print('File: ', file_to_compile)
				print("ERROR: ' ) ' expected")
			lex()
			statements()
			lex()
			if not(token.typ == ENDWHILE):
				print('File: ', file_to_compile )
				print("ERROR: ' endwhile ' expected")

		else:
			print('File: ', file_to_compile )
			print("ERROR: ' ( ' expected")
	else:
		print('File: ', file_to_compile )
		print ("ERROR: ' while ' expected")


def doWhileStat():
	if token.typ == DO:
		lex()
		statements()
		lex()
		if token.typ == WHILE:
			lex()
			if token.typ == LEFTPARENTH:
				lex()
				condition()
				lex()
				if not(token.typ == RIGHTPARENTH):
					print('File: ', file_to_compile )
					print("ERROR: ' ) ' expected")
			else:
				print('File: ', file_to_compile )
				print("ERROR: ' ( ' expected")
		else:
			print('File: ', file_to_compile )
			print ("ERROR: ' while ' expected")
	else:
		print('File: ', file_to_compile )
		print ("ERROR: ' do ' expected")


def loopStat():
	if token.typ == LOOP:
		lex()
		statements()
		lex()
		if not(token.typ == ENDLOOP):
			print('File: ', file_to_compile )
			print ("ERROR: ' endloop ' expected")
	else:
		print('File: ', file_to_compile )
		print ("ERROR: ' loop ' expected")

def exitStat():
	if not(token.typ == EXIT):
		print('File: ', file_to_compile )
		print ("ERROR: ' exit ' expected")

def forcaseStat():
	if token.typ == FORCASE:
		lex()
		while token.typ == WHEN:
			lex()
			afterWhen()
			lex()
		if token.typ == DEFAULT:
			lex()
			if token.typ == ':':
				lex()
				statements()
				lex()
				if not(token.typ == ENDDEFAULT):
					print('File: ', file_to_compile )
					print ("ERROR: ' enddefault ' expected")
			else:
				print('File: ', file_to_compile )
				print ("ERROR: ' : ' expected")
		else:
			print('File: ', file_to_compile )
			print ("ERROR: ' default ' expected")
		lex()
			
		if not(token.typ == ENDFORCASE):
			print('File: ', file_to_compile )
			print ("ERROR: ' endforcase ' expected")


def afterWhen():
	if token.typ == LEFTPARENTH:
		lex()
		condition()
		lex()
		if token.typ == RIGHTPARENTH:
			lex()
			if token.typ == ':':
				lex()
				statements()
			else:
				print('File: ', file_to_compile )
				print ("ERROR: ' : ' expected")
		else:
			print('File: ', file_to_compile )
			print ("ERROR: ' ) ' expected")
	else:
		print('File: ', file_to_compile )
		print ("ERROR: ' ( ' expected")


def incaseStat():
	if token.typ == INCASE:
		lex()
		while token.typ == WHEN:
			lex()
			afterWhen()
			lex()
		if not(token.typ == ENDINCASE):
			print('File: ', file_to_compile )
			print ("ERROR: ' endincase ' expected")

def returnStat():
	lex()
	expression()

def printStat():
	lex()
	expression()

def inputStat():
	if token.typ == INPUT:
		lex()
		if not(token.typ == ID):
			print('File: ', file_to_compile )
			print ("ERROR: ID expected")
	else:
		print('File: ', file_to_compile )
		print ("ERROR: input expected")


def actualpars():
	if token.typ == LEFTPARENTH:
		lex()
		actualparlist()
		lex()
		if not(token.typ == RIGHTPARENTH):
			print ("ERROR ) expected")
	else:
		print('File: ', file_to_compile )
		print ("ERROR: ( expected")

def actualparlist():
	if token.typ == IN or token.typ == INOUT or token.typ == INANDOUT:
		actualparitem()
		lex()
		while token.typ == COMMA:
			lex()
			actualparitem()
			lex()

def actualparitem():
	if token.typ == IN:
		lex()
		expression()
	elif token.typ == INOUT:
		lex()
		if not(token.typ == ID):
			print('File: ', file_to_compile )
			print ("ERROR: After inout, ID expected")

	elif token.typ == INANDOUT:
		lex()
		if not(token.typ == ID):
			print('File: ', file_to_compile )
			print ("ERROR: After inandout, ID expected")
	else:
		print('File: ', file_to_compile )
		print ("ERROR: in/inout/inandout expected")


def condition():
	boolterm()
	lex()
	while token.typ == OR:
		lex()
		boolterm()
		lex()


def boolterm():
	boolfactor()
	lex()
	while token.typ == AND:
		lex()
		boolfactor()
		lex()


def boolfactor():
	if token.typ == NOT:
		lex()
		if token.typ == LEFTBRACK:
			lex()
			condition()
			lex()
			if not(token.typ == RIGHTBRACK):
				print('File: ', file_to_compile )
				print ("ERROR: ] expected")
		else:
				print('File: ', file_to_compile )
				print ("ERROR: [ expected")
	elif token.typ == LEFTBRACK:
			lex()
			condition()
			lex()
			if not(token.typ == RIGHTBRACK):
				print('File: ', file_to_compile )
				print ("ERROR: ] expected")
	else:
		expression()
		lex()
		relationOper()
		lex()
		expression()
	   
def expression():
	optionalSign()
	lex()
	term()
	lex()
	while (token.typ == PLUS) or (token.typ == MINUS):
		addOper()
		lex()
		term()
		lex()

def term():
	factor()
	lex()
	while (token.typ == TIMES) or (token.typ == DIV):
		mulOper()
		lex()
		factor()
		lex()

def factor():
	if token.typ == LEFTPARENTH:
		lex()
		expression()
		lex()
		if not(token.typ == RIGHTPARENTH):
			print('File: ', file_to_compile )
			print ("ERROR: ) expected")
			
	elif token.typ == ID:
		lex()
		idtail()

def idtail():
	if token.typ == LEFTPARENTH:
		actualpars()

def relationOper():
	if not((token.typ == EQUALS) or (token.typ == LESSEQ) or (token.typ == BIGEQ) or (token.typ == BIGGER) or (token.typ == LESS) or (token.typ == DIFF)):
		print('File: ', file_to_compile )
		print("ERROR: <relational oper> expected")
def addOper():
	if not((token.typ == PLUS) or (token.typ == MINUS)):
		print('File: ', file_to_compile )
		print ("ERROR: (+) or (-) expected")

def mulOper():
	if not((token.typ == TIMES) or (token.typ == DIV)):
		print('File: ', file_to_compile )
		print ("ERROR: (*) or (/) expected")

def optionalSign():
	if  (token.typ == PLUS) or (token.typ == MINUS):
		addOper()



def setWordType(mylist):

	if (mylist.isdigit()):
		return NUMBER

	if (mylist.isalpha()):
		if mylist == 'program':
			return PROGR
		elif mylist == 'endprogram':
			return ENDPROG
		elif mylist == 'declare':
			return DECLAR
		elif mylist == 'function':
			return FUNC 
		elif mylist == 'endfunction':
			return ENDFUNC
		elif mylist == 'in':
			return IN 
		elif mylist == 'inout':
			return INOUT
		elif mylist == 'inandout':
			return INANDOUT
		elif mylist == 'if':
			return IF
		elif mylist == 'then':
			return THEN
		elif mylist == 'endif':
			return ENDIF
		elif mylist == 'else':
			return ELSE
		elif mylist == 'while':
			return WHILE
		elif mylist == 'endwhile':
			return ENDWHILE
		elif mylist == 'do':
			return DO
		elif mylist == 'loop':
			return LOOP
		elif mylist == 'endloop':
			return ENDLOOP
		elif mylist == 'exit':
			return EXIT
		elif mylist == 'forcase':
			return FORCASE
		elif mylist == 'when':
			return WHEN
		elif mylist == 'default':
			return DEFAULT
		elif mylist == 'enddefault':
			return ENDDEFAULT
		elif mylist == 'endforcase':
			return ENDFORCASE
		elif mylist == 'incase':
			return INCASE
		elif mylist == 'endincase':
			return ENDINCASE
		elif mylist == 'return':
			return RETURN
		elif mylist == 'print':
			return PRINT
		elif mylist == 'input':
			return INPUT
		elif mylist == 'or':
			return OR
		elif mylist == 'and':
			return AND
		elif mylist == 'not':
			return NOT
		else:
			return ID

	if mylist == '(':
		return LEFTPARENTH
	elif mylist == ')':
		return RIGHTPARENTH
	elif mylist == '[':
		return LEFTBRACK
	elif mylist == ']':
		return RIGHTBRACK
	elif mylist == '=':
		return EQUALS
	elif mylist == '<':
		return LESS
	elif mylist == '>':
		return BIGGER
	elif mylist == '<>':
		return DIFF
	elif mylist == '<=':
		return LESSEQ
	elif mylist == '>=':
		return BIGEQ
	elif mylist == '+':
		return PLUS
	elif mylist == '-':
		return MINUS
	elif mylist == '*':
		return TIMES
	elif mylist == '/':
		return DIV
	elif mylist == ';':
		return SEMICOL
	else:
		return ID


########################################################
#                                                      #
#                 LECTICAL ANALYSER                    #
#                                                      #                
########################################################
# na valoume ta // sta states

def lex():

	my_list = []
	state   = 0
	recog   = -1
	error   = -2
	goback  = 0
	endfile = 0

	if len(sys.argv) != 2:
		print ("Wtf with the arguments")
		exit(0)

	global file_to_compile
	file_to_compile = sys.argv[1]
	file = open(file_to_compile, 'r')
	while (state!=recog) and (state!=error):

		symbol = file.read(1)
		my_list.append(symbol)

		if state == 0:
			if symbol.isalpha():
				state = 1
			elif symbol.isdigit():
				state = 2
			elif symbol == '<':
				state = 3
			elif symbol == '>':
				state = 4
			elif symbol == ':':
				state = 5
			elif symbol in ('+', '-', '*', '/', '=', ',', ';', '(', ')', '[', ']'):
				state = recog
			elif symbol == '':   # EOF
				endfile = 1
				state = recog
			else:
				state = error
		elif state == 1:
			if not((symbol.isalpha()) or (symbol.isdigit())):   # word
				state = recog
				goback = 1
				#na paei pisw
		elif state == 2:
			if not (symbol.isdigit()):  # number
				state = recog
				goback = 1
				#back
		elif state == 3:
			if not(symbol in ('=', '>')):
				print ("back")
				goback = 1
				#back
			state = recog
		elif state == 4:
			if not(symbol == '='):
				print ("back")
				goback = 1;
				#back
			state = recog
		elif state == 5:
			if not(symbol == '='):
				goback = 1\
				#back
			state = recog

	if goback:
		del my_list[-1]
		if not(endfile):
			file.seek(file.tell() - 1)

	my_list = ''.join(my_list)
	typ = setWordType(my_list)
	if state == recog:
		global token
		token = Token(my_list, typ)
	   # PROBLEM ECOUME ENTO

	print(token.mylist1)
	optionalSign()
	

	print ("Number of arg:", len(sys.argv), "arguments")
	print ("Argument List:", str(sys.argv))


lex()
