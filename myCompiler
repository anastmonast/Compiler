#!/usr/bin/env python3

# Despoina Kotsidou       2475
# Anastasia Monastiridou  2488

import sys
file_to_compile = ' '
file = ' '
firsttime = [0]

# ta // mi ksexasoume

#############################
#                           #
#       TOKEN TYPES         #
#                           #
#############################

PROGR       = 1
ENDPROG     = 2
DECLAR      = 3
FUNC        = 4
ENDFUNC     = 5
IN          = 6
INOUT       = 7
INANDOUT    = 8
IF          = 9
THEN        = 10
ENDIF       = 11
ELSE        = 12
WHILE       = 13
ENDWHILE    = 14
DO          = 15
LOOP        = 16
ENDLOOP     = 17
EXIT        = 18
FORCASE     = 19
WHEN        = 20
DEFAULT     = 21
ENDDEFAULT  = 22
ENDFORCASE  = 23
INCASE      = 24
ENDINCASE   = 25
RETURN      = 26
PRINT       = 27
INPUT       = 28
OR          = 29
AND         = 30
NOT         = 31

LEFTPARENTH = 32
RIGHTPARENTH= 33
LEFTBRACK   = 34
RIGHTBRACK  = 35
EQUALS      = 36
LESS        = 37
BIGGER      = 38
DIFF        = 39
LESSEQ      = 40
BIGEQ       = 41
PLUS        = 42
MINUS       = 43
TIMES       = 44
DIV         = 45
SEMICOL     = 46
COMMA       = 47
COLON       = 48
ASSIGN      = 49

ID          = 50
NUMBER      = 51





class Token:
    def __init__(self, mylist1, typ):
        self.mylist1 = mylist1
        self.typ = typ

token = ''

def program():
    if token.typ == PROGR:
        lex()
        if (token.typ == ID):
            lex()
            block()
            lex()
            if not(token.typ == ENDPROG):
                print('File: ', file_to_compile )
                print ("ERROR: ' endprogram ' expected")
        else:
            print("Error, 'ID' expected")
    else:
        print('File: ', file_to_compile )
        print ("ERROR: ' program ' expected")


def block():
    declaration()
    lex()
    subprograms()
    lex()
    statements()
   

def declaration():
    while token.typ == DECLAR:
        lex()
        varlist()
        lex()
        if (token.typ == SEMICOL):
            lex()
        else:
            print('File: ', file_to_compile )
            print ("ERROR: ' ; ' expected")
    print()

def varlist():
    if token.typ == ID:
        lex()
        while token.typ == COMMA:
            lex()
            if not(token.typ == ID):
                print('File: ', file_to_compile )
                print ("ERROR: ' ID ' expected")
            lex()
    print()

def subprograms():
    while token.typ == FUNC:
        subprogram()
        lex()
    print()

def subprogram():
    if token.typ == FUNC:
        lex()
        if (token.typ == ID):
            lex()
            funcbody()
            lex()
            if not(token.typ == ENDFUNC):
                print('File: ', file_to_compile )
                print ("ERROR: ' endfunction ' expected")
        else:
            print('File: ', file_to_compile )
            print ("ERROR: ' ID ' expected")

    print()

def funcbody():
    formalpars()
    lex()
    block()
    

def formalpars():
    if token.typ == LEFTPARENTH:
        formalparlist()
        lex()
        if not(token.typ == RIGHTPARENTH):
            print('File: ', file_to_compile )
            print ("ERROR: ' ) ' expected")
    else:
        print('File: ', file_to_compile )
        print ("ERROR: ' (  ) ' expected")
    

def formalparlist():
    if token.typ == IN or token.typ == INOUT or token.typ == INANDOUT:
        formalparitem()
        lex()
        while token.typ == COMMA:
            lex()
            formalparitem()
            lex()
    print()

def formalparitem():
    if token.typ == IN:
        lex()
        if not(token.typ == ID):
            print('File: ', file_to_compile )
            print ("ERROR: After in, ID expected")
    elif token.typ == INOUT:
        lex()
        if not(token.typ == ID):
            print('File: ', file_to_compile )
            print ("ERROR: After inout, ID expected")

    elif token.typ == INANDOUT:
        lex()
        if not(token.typ == ID):
            print('File: ', file_to_compile )
            print ("ERROR: After inandout, ID expected")
    else:
        print('File: ', file_to_compile )
        print ("ERROR: in/inout/inandout id expected")

    print()

def statements():
    statement()
    lex()
    while token.typ == SEMICOL:
        lex()
        statement()
        lex()
    

def statement():
    if token.typ == ID:
        assignmentStat()
    elif token.typ == IF:
        ifStat()
    elif token.typ == WHILE:
        whileStat()
    elif token.typ == DO:
        doWhileStat()
    elif token.typ == LOOP:
        loopStat()
    elif token.typ == EXIT:
        exitStat()
    elif token.typ == FORCASE:
        forcaseStat()
    elif token.typ == INCASE:
        incaseStat()
    elif token.typ == RETURN:
        returnStat()
    elif token.typ == INPUT:
        inputStat()
    elif token.typ == PRINT:
        printStat()


def assignmentStat():
    if (token.typ == ID):
        lex()
        if (token.typ == ASSIGN):
            lex()
            expression()
        else:
            print("Error, ':=' expected")

    print()

def ifStat():
    if (token.typ == IF):
        if (token.typ == LEFTPARENTH):
            lex()
            condition()
            lex()
            if (token.typ == RIGHTPARENTH):
                lex()
                if (token.typ == THEN):
                    lex()
                    statements()
                    lex()
                    elsepart()
                    lex()
                    if not(token.typ == ENDIF):
                        print("Error, 'endif' expected")
                else: 
                    print("Error, 'then' expected")
            else:
                print("Error, ')' expected")


        else:
            print("Error, '(' expected")


    print()

def elsepart():
    if (token.typ == ELSE):
        lex()
        statements()
    print()

def whileStat():
    if (token.typ == WHILE):
        lex()
        if (token.typ == LEFTPARENTH):
                lex()
                condition()
                lex()
                if (token.typ == RIGHTPARENTH):
                    lex()
                    statements()
                    lex()
                    if not (token.typ == ENDWHILE):
                        print("Error, 'endwhile' expected")
                else:
                    print("Error, ')' expected")
        else:
            print("Error, '(' expected")        


        

    print()

def doWhileStat():
    if (token.typ == DO):
        lex()
        statements()
        if (token.typ == WHILE):
            lex()
            if (token.typ == LEFTPARENTH):
                lex()
                condition()
                lex()
                if not(token.typ == RIGHTPARENTH):
                    print("Error, ')' expected")
            else:
                print("Error, '(' expected")
        else:
            print("Error, 'while' expected")

    print()

def loopStat():
    if (token.typ == LOOP):
        lex()
        statements()
        lex()
        if not (token.typ == ENDLOOP):
            print("Error, 'endloop' expected at line..")
    print()

def exitStat():
    if not (token.typ == EXIT):
        print("Error, 'exit' expected at line..")
    print()

def forcaseStat():
    if (token.typ == FORCASE):
        lex()
        while (token.typ == WHEN):
            lex()
            afterwhen()
            lex()
        if (token.typ == DEFAULT):
            lex()
            if (token.typ == COLON):
                lex()
                statements()
                lex()
                if (token.typ == ENDDEFAULT):
                    lex()
                    if not(token.typ == ENDFORCASE):
                        print("Error, 'endforcase' expected at line..")
                else:
                     print("Error, enddefault expected at line..")
                   
            else:
                print("Error, ':' expected")
        else:
            print("Error, 'default' expected")
    print()
def afterWhen():

    if (token.typ == LEFTPARENTH):
        lex()
        condition()
        lex()
        if (token.type == RIGHTPARENTH):
            lex()
            if (token.type == ':'):
                lex()
                statements()
            else:
                print("Error, ':' expected")
        else:
            print("Error, ')' expected")

    else:
        print("Error '(' expected")



def incaseStat():
    if (token.typ == INCASE):
        lex()
        while ( token.typ == WHEN):
            lex()
            afterwhen()
            lex()
        if not (token.typ == ENDINCASE):
            print("Error, endincase expected at line..")

    print()

def returnStat():
    if (token.typ == RETURN):
        lex()
        expression()
    print()

def printStat():
    if (token.typ == PRINT):
        lex()
        expression()
    

def inputStat():
    if (token.typ == INPUT):
        lex()
        if not (token.typ == ID):
            print("Error, ID expected at line..")
    else:
        print("Error, input expected at line..")

    print()

def actualpars():
    if (token.typ == LEFTPARENTH):
        lex()
        actualparlist()
        lex()
        if not (token.typ == RIGHTPARENTH):
            print("Error, Right Parenthesis expexted at line..")
    else:
        print("Error Left Parenthesis expected")
    print()

def actualparlist():
    if (token.typ == IN or token.typ == INOUT or token.typ == INANDOUT):
        lex()
        actualparitem()
        lex()
        while (token.typ == COMMA):
            lex()
            actualparitem()
            lex()

    print()


def actualparitem():
    if (token.typ == IN):
        lex()
        expression()
    elif (token.typ == INOUT or token.typ == INANDOUT):
        lex()
        if not (token.typ == ID):
            print("Error ID expected at line..")
    else:
        print("Error , in/inout/inandout expected")

    print()

def condition():
    boolterm()
    lex()
    while (token.typ == OR):
        lex()
        boolterm()
        lex()
    print()

def boolterm():
    boolfactor()
    lex()
    while (token.typ == AND):
        lex()
        boolfactor()
        lex()
    print()

def boolfactor():
    if (token.typ == NOT):
        lex()
        if (token.typ == LEFTBRACK):
            lex()
            condition()
            lex()
            if not (token.typ == RIGHTBRACK):
                print("ERROR: Right Bracket expected at line..")
        else:
            print("Error Left Bracket expected at line..")
    elif (token.typ == LEFTBRACK):
        lex()
        condition()
        lex()
        if not (token.typ == RIGHTBRACK):
            print("Error Right Bracket expected at line..")
    else:
        expression()
        lex()
        relationOper()
        lex()
        expression()
    print()

def expression():
    optionalSign()
    lex()
    term()
    lex()
    while(token.type == PLUS or token.typ == MINUS):
        addOper()
        lex()
        term()
        lex()
    print()

def term():
    factor()
    lex()
    while (token.typ == TIMES or token.typ == DIV ):
        mulOper()
        lex()
        factor()
        lex()

    print()

def factor():
    
    if (token.typ == LEFTPARENTH):
        lex()
        expression()
        lex()
        if not (token.typ == RIGHTPARENTH):
            print("ERROR: Right Parenthesis expected at line..")
    elif (token.typ == ID ):
        lex()
        idtail()


    print()

def idtail():
    
    if (token.typ == LEFTPARENTH):
        actualpars() 
    print()

def relationOper():
    if not(token.typ == EQUALS or token.typ == LESSEQ or token.typ == BIGEQ or token.typ == BIGGER or token.typ == LESS or token.typ == DIFF):
        print("ERROR: relation operator expected on line ..")
    print()

def addOper():
    if not (token.typ == MINUS or token.typ == PLUS):
        print("ERROR: (+) or (-) expected on line..")
    print()

def mulOper():
    if not (token.typ == TIMES or token.typ == DIV):

        #line =  file.read().split('\n')[line_number]
        print("ERROR: (*) or (/) expected on line.. ")

    print()

def optionalSign():
    if (token.typ == MINUS or token.typ == PLUS):
        addOper()
    print()



def setWordType(mylist):

    if (mylist.isdigit()):
        return NUMBER

    if (mylist.isalpha()):
        
        if mylist == 'program':
            return PROGR

        elif mylist == 'endprogram':
            return ENDPROG
        elif mylist == 'declare':
            return DECLAR
        elif mylist == 'function':
            return FUNC 
        elif mylist == 'endfunction':
            return ENDFUNC
        elif mylist == 'in':
            return IN 
        elif mylist == 'inout':
            return INOUT
        elif mylist == 'inandout':
            return INANDOUT
        elif mylist == 'if':
            return IF
        elif mylist == 'then':
            return THEN
        elif mylist == 'endif':
            return ENDIF
        elif mylist == 'else':
            return ELSE
        elif mylist == 'while':
            return WHILE
        elif mylist == 'endwhile':
            return ENDWHILE
        elif mylist == 'do':
            return DO
        elif mylist == 'loop':
            return LOOP
        elif mylist == 'endloop':
            return ENDLOOP
        elif mylist == 'exit':
            return EXIT
        elif mylist == 'forcase':
            return FORCASE
        elif mylist == 'when':
            return WHEN
        elif mylist == 'default':
            return DEFAULT
        elif mylist == 'enddefault':
            return ENDDEFAULT
        elif mylist == 'endforcase':
            return ENDFORCASE
        elif mylist == 'incase':
            return INCASE
        elif mylist == 'endincase':
            return ENDINCASE
        elif mylist == 'return':
            return RETURN
        elif mylist == 'print':
            return PRINT
        elif mylist == 'input':
            return INPUT
        elif mylist == 'or':
            return OR
        elif mylist == 'and':
            return AND
        elif mylist == 'not':
            return NOT
        else:
            return ID

    if mylist == '(':
        return LEFTPARENTH
    elif mylist == ')':
        return RIGHTPARENTH
    elif mylist == '[':
        return LEFTBRACK
    elif mylist == ']':
        return RIGHTBRACK
    elif mylist == '=':
        return EQUALS
    elif mylist == '<':
        return LESS
    elif mylist == '>':
        return BIGGER
    elif mylist == '<>':
        return DIFF
    elif mylist == '<=':
        return LESSEQ
    elif mylist == '>=':
        return BIGEQ
    elif mylist == '+':
        return PLUS
    elif mylist == '-':
        return MINUS
    elif mylist == '*':
        return TIMES
    elif mylist == '/':
        return DIV
    elif mylist == ';':
        return SEMICOL
    elif mylist == ':':
        return COLON
    elif mylist == ':=':
        return ASSIGN
    else:
        return ID
def globalchange(firsttime):
    firsttime[0] = 1


########################################################
#                                                      #
#                 LECTICAL ANALYSER                    #
#                                                      #                
########################################################
# na valoume ta // sta states

def lex():

    
    my_list = []
    state   = 0
    recog   = -1
    error   = -2
    goback  = 0
    endfile = 0
    
    if firsttime[0] == 0:

        if len(sys.argv) != 2:
            print ("Wtf with the arguments")
            exit(0)
        global file_to_compile
        global file
        file_to_compile = sys.argv[1]
        file = open(file_to_compile, 'r')
        print("firsttime here")
        globalchange(firsttime)
        
    while (state!=recog) and (state!=error):

        symbol = file.read(1)
        my_list.append(symbol)

        if state == 0:
            if symbol.isalpha():
                state = 1
            elif symbol.isdigit():
                state = 2
            elif symbol == '<':
                state = 3
            elif symbol == '>':
                state = 4
            elif symbol == ':':
                state = 5
            elif symbol in ('+', '-', '*', '/', '=', ',', ';', '(', ')', '[', ']'):
                state = recog
            elif symbol == '':   # EOF
                endfile = 1
                state = recog
            elif symbol.isspace():
                del my_list[-1]
                print("Im here in space")
            else:
                state = error
        elif state == 1:
            if not((symbol.isalpha()) or (symbol.isdigit())):   # word
                state = recog
                goback = 1
                #na paei pisw
        elif state == 2:
            if (symbol.isspace()): #number
                state= recog
                goback = 1
            elif not (symbol.isdigit()):  # wrong number
                state = error
                print("ERROR !!")
                #state = recog
                #goback = 1;
                #back
        elif state == 3:
            if not(symbol in ('=', '>')):
                print ("back")
                goback = 1
                #back
            state = recog
        elif state == 4:
            if not(symbol == '='):
                print ("back")
                goback = 1;
                #back
            state = recog
        elif state == 5:
            if not (symbol == '='):
                goback = 1
            state = recog
            

    if goback:
    
        if not(endfile):
            file.seek(file.tell() - 1)
            del my_list[-1]


    my_list = ''.join(my_list)
    print(my_list)
    print(len(my_list))
    typ = setWordType(my_list)
    if state == recog:
        global token
        token = Token(my_list, typ)
       # PROBLEM ECOUME ENTO
    print(token.typ) 


    print ("Number of arg:", len(sys.argv), "arguments")
    print ("Argument List:", str(sys.argv))


lex()
#mulOper()
#while (state!=error and )
program()
